#!/bin/bash#set java envexport JAVA_HOME=/export/software/jdk1.8.0_65export JRE_HOME=${JAVA_HOME}/jre#在linux中，小数点“.”表示当前路径，冒号“：”在此表示分隔符。export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/libexport PATH=${JAVA_HOME}/bin:$PATH`date -d`#set hadoop envexport HADOOP_HOME=/export/software/hadoop-2.7.4export PATH=${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin:$PATH#日志文件存放的目录log_src_dir=/root/logs/log/#待上传文件存放的目录log_toupload_dir=/root/logs/toupload/#日志文件上传到hdfs的根路径date1=`date -d last-day +%Y_%m_%d`hdfs_root_dir=/data/clickLog/$date1/#打印环境变量信息echo "envs: hadoop_home: $HADOOP_HOME"#读取日志文件的目录，判断是否有需要上传的文件echo "log_src_dir:"$log_src_dir#| 管道符号，是unix一个很强大的功能,符号为一条竖线:"|"。用法:command 1 | command 2#他的功能是把第一个命令command 1执行的结果作为command2的输入传给command 2，例如:ls $log_src_dir | while read fileNamedo	if [[ "$fileName" == access.log.* ]]; then	# if [ "access.log" = "$fileName" ];then		date=`date +%Y_%m_%d_%H_%M_%S`		#将文件移动到待上传目录并重命名		#打印信息		echo "moving $log_src_dir$fileName to $log_toupload_dir"xxxxx_click_log_$fileName"$date"		mv $log_src_dir$fileName $log_toupload_dir"xxxxx_click_log_$fileName"$date		#将待上传的文件path写入一个列表文件willDoing		echo $log_toupload_dir"xxxxx_click_log_$fileName"$date >> $log_toupload_dir"willDoing."$date	fidone#找到列表文件willDoing    -v 排除，反向查找ls $log_toupload_dir | grep will |grep -v "_COPY_" | grep -v "_DONE_" | while read linedo	#打印信息	echo "toupload is in file:"$line	#将待上传文件列表willDoing改名为willDoing_COPY_	mv $log_toupload_dir$line $log_toupload_dir$line"_COPY_"	#读列表文件willDoing_COPY_的内容（一个一个的待上传文件名）  ,此处的line 就是列表中的一个待上传文件的path	cat $log_toupload_dir$line"_COPY_" |while read line	do		#打印信息		echo "puting...$line to hdfs path.....$hdfs_root_dir"		hadoop fs -mkdir -p $hdfs_root_dir		hadoop fs -put $line $hdfs_root_dir	done	mv $log_toupload_dir$line"_COPY_"  $log_toupload_dir$line"_DONE_"done#while read line#do#       …#done < file#read通过输入重定向，把file的第一行所有的内容赋值给变量line，#循环体内的命令一般包含对变量line的处理；然后循环处理file的第二行、第三行。。。#一直到file的最后一行。还记得while根据其后的命令退出状态来判断是否执行循环体吗？#是的，read命令也有退出状态，当它从文件file中读到内容时，状态为0，循环继续执行；#当read从文件中读完最后一行后，下次便没有内容可读了，此时read的退出状态为非0，所以循环才会退出。